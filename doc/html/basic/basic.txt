-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/basic#readme</a>
@package basic
@version 0.1.0.0

module Lib

-- | GADT implementation of logical expressions
--   
--   <pre>
--   data Expr a where
--     Lit :: Bool -&gt; Expr Bool
--     And :: Expr Bool -&gt; Expr Bool -&gt; Expr Bool
--     Or  :: Expr Bool -&gt; Expr Bool -&gt; Expr Bool
--     Xor :: Expr Bool -&gt; Expr Bool -&gt; Expr Bool
--     Not :: Expr Bool -&gt; Expr Bool
--   </pre>
gadtExpr :: ()
data And a
And :: a -> a -> And a
data Or a
Or :: a -> a -> Or a
data Xor a
Xor :: a -> a -> Xor a
data Not a
Not :: a -> Not a
type AndF = Free And

-- | Example lowest-level optimization:
--   
--   <pre>
--   x `<a>And</a>` x = x
--   </pre>
simplAndEqArgs :: Eq a => And a -> Either a (And a)

-- | Lift with the given function, collapsing and reapplying when
--   <a>Left</a> is returned
liftCollapse :: (Functor f, c (Free f a)) => proxy c -> (forall t. c t => f t -> Either t (f t)) -> Free f a -> FreeT f (Either a) a
simplAndEqArgsF :: Eq a => AndF a -> AndF a
reduceSimpl :: Functor f => FreeT f (Either a) a -> Free f a
type OrF = Free Or
type XorF = Free Xor
type NotF = Free Not
type ExprF = Free (And :+: Or :+: Xor :+: Not)
getAnd :: ExprF a -> Either (AndF a) (ExprF (AndF a))
getAndF :: ExprF a -> ExprF (AndF a)
fromAndF :: AndF a -> ExprF a
partAnd :: ExprF (AndF a) -> ExprF (ExprF (AndF a))
type AndO = Free (Or :+: Xor :+: Not)

-- | Part and dart notes
--   
--   <pre>
--   part :: [] . Maybe -&gt; [] . (Maybe . NonEmpty) . Maybe
--   part ~ map Just . groupOn isJust
--   
--   dart :: [] . (Maybe . NonEmpty) . Maybe -&gt; [] . Maybe . NonEmpty
--   dart ~ map (fmap (fmap fromJust))
--   
--   pver :: [] . Maybe -&gt; [] . Maybe . []
--   pver ~ fmap (fmap toList) . dart . part
--   </pre>
--   
--   An expression type is (up to) the recursive completion of the
--   exclusive or (non-inclusive sum) of two expression types.
--   
--   <pre>
--   A functor is (up to) isomorphic to the recursive completion of the <tt>xor</tt> of two other functors.
--     f ~ g <tt>xor</tt> h
--   With the boundary language introduced before, we may bound the "leafy" subtrees that completely consist of one functor.
--     This gives us: f -&gt; f . g (|| f -&gt; f . h)
--   Next, we split out the trees that contain those, and only the other functor:
--     f . g -&gt; f . h . g
--   Finally we repeat the process for the original "sub" functor:
--     f . h . g -&gt; f . g . h . g
--   Alternatively, we can think of the pattern: "^.*GHG$", where <a>G</a>, <a>H</a> represent the matcher of a single element of a path in g, h, resp.
--   </pre>
partDartPver :: ()

-- | <pre>
--   Expr = ExprL <tt>xor</tt> ExprR
--   splitL :: Expr -&gt; Expr . ExprL
--   splitR :: Expr -&gt; Expr . ExprR
--   splitRL :: Expr . ExprR -&gt; Expr . (ExprR . ExprL) . ExprR
--   
--   splitLR :: Expr . ExprL -&gt; Expr . (ExprL . ExprR) . ExprL
--   assoc :: Expr . (ExprL . ExprR) . ExprL -&gt; Expr . ExprL . (ExprR . ExprL)
--   joinRL :: ExprR . ExprL -&gt; Expr
--   push :: Expr . ExprL -&gt; Expr . ExprL . Expr
--   push = fmap (fmap joinRL) . assoc . split
--   
--   pushLR :: Expr . ExprL -&gt; Expr . ExprL . ExprR . ExprL
--   pushLR = assoc . split
--   
--   part :: ExprF . AndF -&gt; ExprF . (AndF . AndO) . AndF
--   
--   dart :: (AndF . AndO) . AndF -&gt; AndF . (AndO . AndF)
--   
--   push :: ExprF
--   
--   A "leafy" Subtree of And's is: AndF a -&gt; AndF (Pure a)
--     A subexpression of Just And's
--   
--   A "branchy" Subtree of And's is AndF (not Pure) -&gt; AndF (ExprF a)
--     A subexpression of And's ending is non-And, then And, etc..
--   </pre>
pushWithSplits :: ()

-- | Several logical forms:
--   
--   <pre>
--   Or (And a)
--   (x &amp;&amp; y) || z =&gt; (x || y) &amp;&amp; (y || z)
--   (x y z w-&gt;(x &amp;&amp; y) || (z &amp;&amp; w) == (x || z) &amp;&amp; (x || w) &amp;&amp; (y || z) &amp;&amp; (y || w))
--   
--   DNF
--   (x &amp;&amp; y) || (z &amp;&amp; w)
--   
--   CNF
--   (w ∨ x) ∧ (w ∨ y) ∧ (x ∨ z) ∧ (y ∨ z)
--   
--   (x &amp;&amp; y) <tt>xor</tt> (z &amp;&amp; w)
--   
--   CNF
--   (¬w ∨ ¬x ∨ ¬y ∨ ¬z) ∧ (w ∨ x) ∧ (w ∨ y) ∧ (x ∨ z) ∧ (y ∨ z)
--   </pre>
logicalForms :: ()

-- | <a>undefined</a>
partAndo :: ExprF (AndF a) -> ExprF (AndO (AndF a))
dartAndo :: ExprF (AndO (AndF a)) -> ExprF (AndF (AndO a))

-- | <a>undefined</a>
--   
--   <pre>
--   dartAnd (Pure x) = _ x
--   dartAnd (Free (L1 (And x y))) = _ x
--   dartAnd (Free (R1 (L1 x))) = _ x
--   dartAnd (Free (R1 (R1 x))) = _ x
--   dartAnd (Free (R1 (R1 (L1 (Xor x y))))) = _ x y
--   dartAnd (Free (R1 (R1 (R1 (Not x))))) = _ x
--   
--   dartAnd (Pure (Pure x)) = Pure $ Pure <a>$</a> x
--   dartAnd (Pure (Free (L1 (And x y)))) =
--   </pre>
dartAnd :: ExprF (ExprF (AndF a)) -> ExprF (AndF (ExprF a))
pushAnd :: ExprF (AndF a) -> ExprF (AndF (ExprF a))
qartAnd :: ExprF (ExprF (AndF a)) -> ExprF (AndF a)
bartAnd :: ExprF (AndF (ExprF a)) -> ExprF (ExprF (AndF a))
pullAnd :: ExprF (AndF (ExprF a)) -> ExprF (AndF a)

-- | Simplify recursively
--   
--   <pre>
--   simplAndEqLoop xs =
--     (&gt;&gt;= fromAndF) . pullAnd . fmap simplAndEqArgsF . pushAnd . getAndF $ xs
--   </pre>
simplAndEqLoop :: Eq a => ExprF a -> ExprF a
instance Data.Traversable.Traversable Lib.Not
instance Data.Foldable.Foldable Lib.Not
instance GHC.Base.Functor Lib.Not
instance GHC.Read.Read a => GHC.Read.Read (Lib.Not a)
instance GHC.Show.Show a => GHC.Show.Show (Lib.Not a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Lib.Not a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Not a)
instance Data.Traversable.Traversable Lib.Xor
instance Data.Foldable.Foldable Lib.Xor
instance GHC.Base.Functor Lib.Xor
instance GHC.Read.Read a => GHC.Read.Read (Lib.Xor a)
instance GHC.Show.Show a => GHC.Show.Show (Lib.Xor a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Lib.Xor a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Xor a)
instance Data.Traversable.Traversable Lib.Or
instance Data.Foldable.Foldable Lib.Or
instance GHC.Base.Functor Lib.Or
instance GHC.Read.Read a => GHC.Read.Read (Lib.Or a)
instance GHC.Show.Show a => GHC.Show.Show (Lib.Or a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Lib.Or a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Or a)
instance Data.Traversable.Traversable Lib.And
instance Data.Foldable.Foldable Lib.And
instance GHC.Base.Functor Lib.And
instance GHC.Read.Read a => GHC.Read.Read (Lib.And a)
instance GHC.Show.Show a => GHC.Show.Show (Lib.And a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Lib.And a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.And a)
instance Data.Functor.Classes.Eq1 Lib.Not
instance Data.Functor.Classes.Show1 Lib.Not
instance Data.Functor.Bind.Class.Apply Lib.Not
instance Data.Functor.Classes.Eq1 Lib.Xor
instance Data.Functor.Classes.Show1 Lib.Xor
instance Data.Functor.Bind.Class.Apply Lib.Xor
instance Data.Functor.Classes.Eq1 Lib.Or
instance Data.Functor.Classes.Show1 Lib.Or
instance Data.Functor.Bind.Class.Apply Lib.Or
instance Data.Functor.Classes.Eq1 Lib.And
instance Data.Functor.Classes.Show1 Lib.And
instance Data.Functor.Bind.Class.Apply Lib.And
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (f GHC.Generics.:+: g)
